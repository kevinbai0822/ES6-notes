# ES6学习笔记

## 变量的解构赋值

### 数组的解构赋值
ES6可以按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。
```
/*es5*/
var a = 1;
var b = 2;
var c = 3;

/*es6*/
var [a,b,c] = [1,2,3];
```
ES6允许按照变量对应的位置，从数组中提取值。  
`本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。`
```
let [l,[[e],o]] = [1,[[2],3]];
console.log(l); //1
console.log(e); //2
console.log(o); //3

let [,,third] = ['l','e','o'];
console.log(third); //o

let [x,,y] = [1,2,3];
x //1
y //3

let [head, ...tail] = [1,2,3,4];
head //1
tail //[2,3,4]
```
如果解构不成功，变量的值就等于undefined。

另一种情况就是不完全解构，等号左边的模式只匹配等号右边数组的一部分。这种情况下，结构依然可以成功。
```
let [x,y] = [1,2,3];
x //1
y //2

let [a,[b],d] = [1,[2,3],4];
a //1
b //2
d //4
```

如果等号右边不是数组(严格来说，不是可遍历的解构)，那么将会报错。
```
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
//error
```
上面的表达式都会报错，因为等号右边，要么转为对象后不具备Iterator(迭代器)接口，要么本身就不具备Iterator接口。

对于Set结构，也可以使用数组的解构赋值。
```
let [x,y,z] = new Set(['a','b','c'])
```
只要某种数据结构具有Interator接口，都可以采用数组形式的解构赋值。

#### 默认值
解构赋值允许指定默认值。
```
var [foo = true] = [];
foo //true

[x,y = 'b'] = ['a'] //x='a' y='b'
[x,y = 'b'] = ['a',undefined] //x='a' y='b'

```
ES6内部使用严格相等运算符(===)来判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值不会生效。这意味着，如果一个值为null，那么解构不会生效，因为null严格上不等于undefined。默认值可以用到解构赋值的其他变量，但变量必须已经声明。

### 对象的解构赋值
解构不仅可以用于数组,还可以用于对象。
```
var {a,b} = {a:'123',b:'456'};
a //123
b //456
```
需要注意的是对象的解构与数组的不同之处在于，数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性是没有次序的，变量必须与属性同名，才能取到正确的值。
```
var {b,a} = {a:'123',b:'456'}; //变量的顺序不影响取值
a //123
b //456

var c = {a:'123',b:'456'}; //属性与变量名不同，取不到值
c //undefined
```
实际上，对象的解构赋值是以下形式的简写
```
var {a:a,b:b} = {a:'123',b:'456'};
```
这说明，对象解构的内部机制，是先找到同名的属性，然后赋给对应的变量，真正被赋值的是同名属性对应的变量，而不是同名的属性。使用let和const声明过的变量，不可用于对象的解构赋值，否则会报错。  
对象的解构赋值同样可用于嵌套解构:
```
let obj = {
    p:[
        'hello',
        {
            y: 'sir'
        }
    ]
}

let {p:[x,{y}]} = obj;
x //hello
y //sir
```
对象的解构赋值也可以指定默认值:
```
var {x,y=2} = {x:1};
x //1
y //2
```
如果将一个已经声明的变量用于解构赋值，必须小心:
```
var x;
{x} = {x:1} //syntax error
```
上面的例子会报错，因为javascript会将{}理解成一个代码块，只有不将大括号写在行首，避免javascript将其解释为代码块。

### 字符串的解构赋值
字符串也可以解构赋值：
```
const [a,b,c,d,e] = 'hello';
```
此时字符串被转换成一个类似数组的对象，类似数组的对象都有length属性，所以也可以对该属性进行解构赋值。
```
let {length: len} = 'leo';
len //3
```

### 数值和布尔值的解构赋值
```
let {toString: s} = 123;
s === Number.prototype.toString //true

let {toString: s} = true;
s === Boolean.prototype.toString //true
```
数值和布尔值的包装对象都有toString属性，所以s可以取到值，解构赋值的规则是只要等号右边不是对象，就先将其转化为对象。所以，undefined和null不能进行解构赋值，因为它们无法转化为对象。

### 函数参数的解构赋值
函数的参数也能通过解构赋值的形式传递。
```
[[1,2],[3,4]].map(([a,b]) => a+b);
//[3,7]
```
实际上箭头函数的参数不是数组，而是通过解构赋值得到的变量a和b。

### 圆括号问题
`ES6规则是，只要有可能导致结构歧义，就不得使用圆括号，但是这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中使用圆括号。`

### 解构赋值的用途
#### 交换变量的值
在ES5中如果要交换变量的值，通常需要使用一个临时变量。但是在ES6中可以直接
```
[x,y] = [y,x];
```
#### 从函数返回多个值
函数只能返回一个值，如果要返回多个值，只能放在对象或者数组中返回，解构赋值可以很方便的取到它们。
```
function fuc(){
    return [1,2,3];
}
var [a,b,c] = func();
```
#### 函数参数的定义
解构赋值可以很方便的将一组参数与变量名对应起来。
```
function fun([x,y,z]){}
f([1,2,3])

function fun1({x,y,z}){}
f({z:1,x:2,y:3})
```
使用对象的解构赋值进行传参，可以不用担心参数的顺序，只要同名就行。
#### 函数参数的默认值
这样就可以避免在函数体内再写设置默认值的代码。
#### 遍历Map解构
任何部署了Iterator接口的对象，都可以用`for...of`循环遍历。
```
var map = new Map();
map.set("first","hello");
map.set("second","world");

for(let [key,value] of map){
    console.log(key + 'is' + value);
}
```
#### 输入模块的指定方法
加载模块式，往往需要指定输入哪些方法。解构赋值使得语句变得非常清晰。
```
const {fun1,fun2} = require("file");
```